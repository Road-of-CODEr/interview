# HTTP

## http vs https vs http/1.x vs http/2

<details>
<summary>정답 보기</summary>

### http

HTTP는 웹 페이지와 같은 자원을 주고 받을 때 쓰는 **통신 규약**이다.

- TCP/IP 통신, 80 포트

### http/1.x

- 텍스트 기반 프로토콜
  - 아스키코드로 작성되었으므로 읽기에는 편하지만 데이터가 커짐
- Connection 한 개당 하나의 요청을 처리하도록 설계
  - 동시에 리소스를 주고 받는 것이 불가능
  - 요청과 응답이 순차적으로 이루어짐
  - HTTP 문서 내에 포함된 다수의 리소스(image, css, script)를 처리하려면 요청할 리소스의 개수에 비례하여 Latency(대기시간)이 길어짐
- HOL(Head Of Line) Blocking이 발생할 수 있다
  - HOL 블로킹이란 네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다
- RTT(Round Trip Time) 증가
  - Connection 하나에 요청 한 개를 처리하는 특성때문에 매번 요청 별로 Connection을 만들게 되고 TCP상에서 동작하는 HTTP의 특성상 3-way handshake가 반복적으로 일어나며, 불필요한 RTT 증가와 네트워크 지연을 초래하여 성능을 지연시킨다
- 무거운 Header 구조
  - 매 요청마다 중복된 헤더 값을 전송하게 되며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송된다. 이러한 반복적인 헤더 전송, 쿠키 정보로 인해 헤더 크기가 증가한다
- 1.1부터 persistent connection(e.g., keep-alive)를 default로 지원한다

### http/2

- 이진(binary) 프로토콜
- SPDY 프로토콜을 기반으로 동작
- https 연결에서만 작동한다
- Multiplexed Streams
  - connection 한 개로 동시에 여러 개의 메시지를 주고 받을 수 있으며, 응답은 순서에 상관없이 stream으로 주고 받는다.
- Stream Prioritization
  - 리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결
    - ex. 문서 내에 CSS파일 1개와 이미지 파일 2개가 존재하고 이를 클라리언트가 요청하는 상황에서 이미지 파일보다 CSS 파일의 수신이 늦어진다면 렌더링에 문제가 생기게 되는데 이를 해결함.
- Server Push
  - 클라이언트가 요청하지 않은 리소스를 서버가 사전에 푸쉬를 통해 전송할 수 있다.
    - ex. 푸쉬가 가능하면 클라이언트가 추후에 HTML문서를 요청할 때 해당 문서 내의 리소스를 사전에 클라이언트에서 다운로드할 수 있도록 하여 클라이언트의 요청을 최소화할 수 있음
- Header Compression
  - 헤더 정보를 HPACK 방식으로 압축한다.
- [더 자세히 보기](https://web.dev/performance-http2)

### https

http에 보안이 추가된 버전이다. TLS 프로토콜을 사용하여 데이터를 주고 받는 **통신 규약**이다.

- TCP/IP 통신, 443 포트
- SSL/TLS와 함께 HTTP/2를 사용한다

#### https 연결 과정

1. 클라이언트(브라우저)가 서버에 최초 연결 시도
2. 서버는 공개키(CA)를 브라우저에게 전송
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급
4. 브라우저는 세션키를 보관하고 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 획득
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터 전송시 세션키로 암호화/복호화를 진행

#### https 발급 과정

1. A 기업이 http 기반의 앱에 https를 적용하기 위해 공개키/개인키를 발급
2. CA 기업에게 돈을 지불하고 공개키를 저장하는 인증서의 발급을 요청
3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에게 이를 제공함
4. A기업은 클라이언트에게 암호화된 인증서를 제공함
5. 브라우저는 CA기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 세션키를 공유함

만약 인증된 CA 기관의 인증서가 아닐 경우 `NOT SECURE` 빨간 자물쇠가 표시된다.

</details>
