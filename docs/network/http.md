# HTTP

## HTTP란 무엇인가요?

<details>
<summary>정답 보기</summary>

### HTTP (Hypertext Transfer Protocol)

> 클라이언트(브라우저)와 서버 간에 자원을 주고 받을 때 사용하는 **통신 규약**이다.

- 브라우저와 서버간에 HTTP 통신 과정에서 보안에 대해 고려되지 않았기에 중간에 트래픽을 가로챈다면 요청/응답 정보를 확인할 수 있다.
- TCP/IP 통신, 80 포트를 사용한다.

### HTTP 1.1

- 텍스트 기반 프로토콜
  - 아스키코드로 작성되었으므로 읽기에는 편하지만 데이터가 커짐
- 기본적으로 `connection less` 프로토콜(Connection 한 개당 하나의 요청을 처리)이지만 `keep-alive`, `파이프라이닝` 으로 성능 향상 도모 가능
  - 킵얼라이브(Keep-Alive) 커넥션 지원 -> 커넥션을 유지하고 재사용함으로써 TCP 커넥션을 맺고 끊는 오버헤드를 줄일 수 있음
  - RTT가 줄어들고, 3-way handshake 횟수가 즐어든다
  - 파이프라이닝(Pipelining) 지원 -> 이전 요청의 응답을 기다리지 않고, 여럴 요청을 연속적으로 보낼 수 있음
- 파이프라이닝이 순차적으로 처리되기 때문에 `HOLB(Head Of Line Blocking)` 문제가 발생할 수 있음
  - HOL 블로킹: 네트워크에서 같은 큐에 있는 패킷이 첫 번째 패킷에 의해 지연될 때 발생하는 성능 저하 현상을 말한다
- Cache Control: 캐시 컨트롤 헤더를 도입하여 웹 콘텐츠의 캐시 가능성과 유효기간을 명시적으로 지정할 수 있게됨 -> 네트워크 대역폭 사용량을 줄일 수 있음

#### HTTP 1.1의 문제점

- Connection 한 개당 하나의 요청을 처리하도록 설계
  - 동시에 리소스를 주고 받는 것이 불가능
  - 요청과 응답이 순차적으로 이루어짐
  - HTTP 문서 내에 포함된 다수의 리소스(image, css, script)를 처리하려면 요청할 리소스의 개수에 비례하여 Latency(대기시간)이 길어짐
- HOL(Head Of Line) Blocking이 발생할 수 있다
- RTT(Round Trip Time) 증가
  - Connection 하나에 요청 한 개를 처리하는 특성때문에 매번 요청 별로 Connection을 만들게 되고 TCP상에서 동작하는 HTTP의 특성상 3-way handshake가 반복적으로 일어나며, 불필요한 RTT 증가와 네트워크 지연을 초래하여 성능을 지연시킨다
- 무거운 Header 구조
  - 매 요청마다 중복된 헤더 값을 전송하게 되며, 서버 도메인에 관련된 쿠키 정보도 헤더에 함께 포함되어 전송된다. 이러한 반복적인 헤더 전송, 쿠키 정보로 인해 헤더 크기가 증가한다

### HTTP 2.0

- HTTPS 없이도 사용 가능하지만, 브라우저들이 HTTPS 기반하에 HTTP2가 작동하도록 막아두었다.
  - HTTP2에서 HTTPS를 사용하려면 보안 프로토콜 TLS 1.2 이상이 필요하다.
- SPDY 프로토콜을 기반으로 동작한다
- 다중화(Multiplexed Streams) 지원: 하나의 TCP 연결에서 여러 개의 요청과 응답을 동시에 처리할 수 있게됨 -> 우선순위를 지정해줘야함(Stream Prioritization) -> 응답은 순서에 상관없이 stream으로 주고 받는다.
  - 리소스 간의 의존관계에 따른 우선순위를 설정하여 리소스 로드 문제를 해결
    - ex. 문서 내에 CSS파일 1개와 이미지 파일 2개가 존재하고 이를 클라리언트가 요청하는 상황에서 이미지 파일보다 CSS 파일의 수신이 늦어진다면 렌더링에 문제가 생기게 되는데 이를 해결함
- 이진 프레임(Binary Framing)을 사용하여 데이터를 전송함 -> 텍스트 기반의 HTTP 1.1에 비해 전송 과정에서 더 적은 오버헤드를 발생시킴
- 서버 푸시(Server Push) 기능이 도입되어, 클라이언트가 요청하기 전에 서버가 미리 필요한 리소스를 전송할 수 있게됨 -> 페이지 로딩 시간 개선
  - ex. 푸쉬가 가능하면 클라이언트가 추후에 HTML문서를 요청할 때 해당 문서 내의 리소스를 사전에 클라이언트에서 다운로드할 수 있도록 하여 클라이언트의 요청을 최소화할 수 있음
- 헤더 압축(Header Compression)을 통해 헤더 정보를 HPACK 방식으로 압축해 요청 및 응답 헤더의 크기를 줄일 수 있음 -> 전송 과정에서 필요한 데이터가 줄어들고 효율성이 향상
- [더 자세히 보기](https://web.dev/performance-http2)

## FYI

### HTTP 0.9

- 클라이언트와 서버간의 요청-응답 프로토콜
- TCP/IP 위에서 동작하는 ASCII 프로토콜(요청과 응답이 ASCII 캐릭터로 이루어짐)
- 서버와 클라이언트 간의 커넥션은 매번 요청이 끝날때 마다 종료됨 -> 매번 새로 TCP 커넥션을 맺어야함 -> RTT(Round Trip Time) 증가
- `GET /about/` 과 같이 메서드와 원하는 문서의 경로를 포함한 한줄의 명령어로 이루어짐 -> 응답은 해당 페이지의 하이퍼텍스트 문서(html)

### HTTP 1.0

- 요청 헤더, 응답 헤더가 추가됨
- 응답 상태 정보도 포함됨(e.g. `HTTP/1.0 200 OK`)
- 응답 객체는 하이퍼 텍스트로 한정되지 않음(이미지, 미디어 등도 내려받을 수 있게됨, 사실상 이때부터 HTTP라는 용어가 어울리지 않게됨)
- 여전히 서버와 클라이언트 간의 커넥션은 매번 요청이 끝날때 마다 종료됨

### Methods

- GET, POST, PUT, DELETE, HEAD, OPTIONS, TRACE, CONNECT
  - REST API 메서드 -> GET, POST, PUT, DELETE

### 쿠키

비연결형인 HTTP에서 상태 정보 유지를 위함이다. 클라이언트 로컬에 저장되는 '키: 값'의 쌍으로 만료일자가 존재한다.

</details>

## HTTPS와 HTTP의 차이는 무엇인가요?

<details>
<summary>정답 보기</summary>

### HTTPS (Hypertext Transfer Protocol Secure)

> HTTP에 보안이 추가된 버전이다. TLS 프로토콜을 사용하여 데이터를 주고 받는 **통신 규약**이다.
HTTP 프로토콜이 TCP 계층에서 동작한다고 하면, 여기에 SSL, TLS 라는 보안 계층을 올려 보안이 보장된 통신 프로토콜

- 신뢰할 수 있는 SSL 인증서 판매 기관에서 SSL 인증서를 구매 > SSL/TLS 인증서를 사용하여 웹 서버의 신원을 인증함
- 기본적으로 443 포트 번호를 사용
- SSL/TLS와 함께 HTTP/2를 사용한다
- HTTPS는 검색 엔진 최적화(SEO)에 도움될 수 있음
- 개인정보 유출 위험을 완전히 막지는 못한다. 다만 암호화한 정보가 유출되는것뿐이다.

#### https 연결 과정

1. 클라이언트(브라우저)가 서버에 최초 연결 시도
2. 서버는 공개키(CA)를 브라우저에게 전송
3. 브라우저는 인증서의 유효성을 검사하고 세션키를 발급
4. 브라우저는 세션키를 보관하고 추가로 서버의 공개키로 세션키를 암호화하여 서버로 전송
5. 서버는 개인키로 암호화된 세션키를 복호화하여 세션키를 획득
6. 클라이언트와 서버는 동일한 세션키를 공유하므로 데이터 전송시 세션키로 암호화/복호화를 진행

#### https 발급 과정

1. A 기업이 http 기반의 앱에 https를 적용하기 위해 공개키/개인키를 발급
2. CA 기업에게 돈을 지불하고 공개키를 저장하는 인증서의 발급을 요청
3. CA 기업은 CA기업의 이름, 서버의 공개키, 서버의 정보 등을 기반으로 인증서를 생성하고, CA 기업의 개인키로 암호화하여 A기업에게 이를 제공함
4. A기업은 클라이언트에게 암호화된 인증서를 제공함
5. 브라우저는 CA기업의 공개키를 미리 다운받아 갖고 있어, 암호화된 인증서를 복호화함
6. 암호화된 인증서를 복호화하여 얻은 A기업의 공개키로 세션키를 공유함

만약 인증된 CA 기관의 인증서가 아닐 경우 `NOT SECURE` 빨간 자물쇠가 표시된다.

</details>
